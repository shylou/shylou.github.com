<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[liushy]]></title>
  <subtitle><![CDATA[I'm waiting for you]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liushy.com/"/>
  <updated>2015-02-02T12:25:06.935Z</updated>
  <id>http://liushy.com/</id>
  
  <author>
    <name><![CDATA[Liushy]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[基于floodlight的队列调整]]></title>
    <link href="http://liushy.com/2015/02/02/sflow-queue/"/>
    <id>http://liushy.com/2015/02/02/sflow-queue/</id>
    <published>2015-02-02T12:16:13.000Z</published>
    <updated>2015-02-02T12:22:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>介绍本次实验前，我想先讲讲关于流量监控的事。嗯，<a href="http://liushy.com/2015/01/27/sflow-ddos/" target="_blank" rel="external">基于sflow的ddos防御</a> 的成功，坚定了我继续基于sflow做流量监控。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>介绍本次实验前，我想先讲讲关于流量监控的事。嗯，<a href="http://liushy.com/2015/01/27/sflow-ddos/" target="_blank" rel="external">基于sflow的ddo]]>
    </summary>
    
      <category term="sflow" scheme="http://liushy.com/tags/sflow/"/>
    
      <category term="floodlight" scheme="http://liushy.com/tags/floodlight/"/>
    
      <category term="queue" scheme="http://liushy.com/tags/queue/"/>
    
      <category term="qos" scheme="http://liushy.com/tags/qos/"/>
    
      <category term="SDN" scheme="http://liushy.com/categories/SDN/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sflow流量监控之ddos防御]]></title>
    <link href="http://liushy.com/2015/01/27/sflow-ddos/"/>
    <id>http://liushy.com/2015/01/27/sflow-ddos/</id>
    <published>2015-01-27T08:17:47.000Z</published>
    <updated>2015-01-27T08:25:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近做的一个实验，需要获取链路接口的实时信息，比如带宽，流量统计等等。起初，我打算从openflow协议中的计数器入手，openflow交换机对每一个流维护一个计数器，控制器可以从这些计数器上查询每条链路的实时流量信息。随着网络规模增大，流量增加时，对计数器管理会变得越来越消耗系统资源，如<a href="http://www.openflowhub.org/display/floodlightcontroller/FAQ+Floodlight+OpenFlow+Controller" title="Floodlight FAQ" target="_blank" rel="external">Floodlight FAQ</a>所提到对控制器而言这样的监控很难准确的，所以就否定了在控制器上实现流量监控的想法，转而考虑通过第三方平台监控每条链路的实时流量信息。sflow可以提供周期性的网络接口统计采样和数据包采样，能够提供各接口的流量信息，且几乎不会对被统计设备造成任何负担，管理成本极低。sflow的部署分为两部分：sflow agent和sflow collector。sflow agent内嵌入网络设备中获取设备的实时信息并封装成sflow报文发送给sflow collector。sflow collector汇总后得出统计数据。初次使用sflow监控流量，做了一个ddos防御的实验。   </p>
<h2 id="实验环境">实验环境</h2>
<p>本次实验是在一台物理主机上完成实验拓扑，控制器部署和sflow部署。通过mininet模拟一个switch，三台host。控制器使用Floodlight。由于mininet已经部署了sflow agent，所以只需要部署sflow collector。<br>实验拓扑如下图：<br><img src="/img/ddos-topo.png" alt="ddos-topo"><br>sflow官网推荐了几款sflow软件如sflow-trend,sflow-rt等，这里我选择的是sflow-rt，安装sflow-rt很简单。<br>1.首先，下载<a href="http://www.inmon.com/products/sFlow-RT.php" target="_blank" rel="external">官方压缩包</a><br>2.然后解压安装：    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$tar</span> -zxvf sflow.tar.gz   </div><div class="line"><span class="variable">$cd</span> sflow/sflow-rt   </div><div class="line">$./start.sh</div></pre></td></tr></table></figure>


<p>在ovs交换机上还要配置sflow agent，输入以下命令：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$sudo</span> ovs-vsctl -- --id=@sflow create sflow agent=eth0 target=\<span class="string">"192.168.2.233:6343\" header=128 sampling=10 polling=1 -- set bridge s1 sflow=@sflow</span></div></pre></td></tr></table></figure>


<p>注意：agent是要监听的网卡，这个网卡一定要能监听到我们所需的交换机的流量，target是sflow collector所在的ip地址，bridge设定需要监听的交换机。   </p>
<h2 id="实验原理">实验原理</h2>
<p>sflow-rt统计到的每个接口的流量信息，我们可以通过sflow-rt的rest api获取json数据并对json数据进行解析获得。对解析到的数据进行判断分析后即可实施策略。本次实验原理如下：<br>1.首先对sflow-rt进行配置，设定metric=ddos,并设定它的阈值，当监测到的流量超过这个阈值时即判断为ddos；<br><em>定义地址组</em>：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -H <span class="string">"Content-Type:application/json"</span> -X PUT --data <span class="string">"{external:['0.0.0.0/0'], internal:['10.0.0.0/8']}"</span> http://localhost:<span class="number">8008</span>/group/json</div></pre></td></tr></table></figure>


<p><em>定义流 </em>：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -H <span class="string">"Content-Type:application/json"</span> -X PUT --data <span class="string">"{keys:'ipsource,ipdestination', value:'frames', filter:'sourcegroup=external&destinationgroup=internal'}"</span> http://localhost:<span class="number">8008</span>/flow/incoming/json</div></pre></td></tr></table></figure>


<p><em>定义阈值</em>：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -H <span class="string">"Content-Type:application/json"</span> -X PUT --data <span class="string">"{metric:'ddos', value:1000}"</span> http://localhost:<span class="number">8008</span>/threshold/incoming/json</div></pre></td></tr></table></figure>

<p>2.若判断为ddos，即调用Floodlight的staticflowentrypusher对ddos攻击包进行丢弃；<br>由于sflow获取的的openflow信息是使用snmp中定义的ifindex对各接口进行标记，而openflow有它自己的标记方式，所以应该对openflow端口号和ifindex端口号进行映射。本次实验采用nodejs作为应用语言。    </p>
<h2 id="实验结果">实验结果</h2>
<p>本次实验ddos攻击采取host1向host2泛洪的方式。命令如下：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mininet&gt;h1 ping <span class="operator">-f</span> h2</div></pre></td></tr></table></figure>


<p>运行ddos防御应用前：<br><img src="/img/ddos泛洪.png" alt="ddos"><br>我们可以看到，未运行ddos防御应用时，h1向h2泛洪的数据包达到了大约每秒30k个包。<br>接下来运行ddos防御应用：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodejs ddosm.js</div></pre></td></tr></table></figure>


<p>运行ddos防御应用后：<br><img src="/img/ddos截取.png" alt="ddos2"><br>可以看出，运行ddos防御应用后，h1向h2泛洪的包迅速被完全的丢弃了。   </p>
<h2 id="总结">总结</h2>
<p>写这篇文主要目的不是介绍怎么写应用，而是对sflow性能的一个展示。流量监控是sdn中很重要的一环，我们在获取各个接口的实时信息后，可以实现很多的服务，比如负载均衡，QOS，流量工程等。这也是我初次尝试sflow,还有很多不解的地方，我的想法是，做好sflow与控制器的交互，完善流量监控的功能，为以后的各种服务提供帮助。<br><strong>参考网站</strong>：<a href="http://blog.sflow.com/2013/05/controlling-large-flows-with-openflow.html" target="_blank" rel="external">sflow官博</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>最近做的一个实验，需要获取链路接口的实时信息，比如带宽，流量统计等等。起初，我打算从openflow协议中的计数器入手，openflow交换机对每一个流维护一个计数器，控制器可以从这些计数器上查询每条链路的实时流量信息。随着网络规模增]]>
    </summary>
    
      <category term="sflow" scheme="http://liushy.com/tags/sflow/"/>
    
      <category term="floodlight" scheme="http://liushy.com/tags/floodlight/"/>
    
      <category term="ddos" scheme="http://liushy.com/tags/ddos/"/>
    
      <category term="SDN" scheme="http://liushy.com/categories/SDN/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDN环境下两主机通信过程]]></title>
    <link href="http://liushy.com/2014/11/15/floodlight-twohosts-ping/"/>
    <id>http://liushy.com/2014/11/15/floodlight-twohosts-ping/</id>
    <published>2014-11-15T11:47:25.000Z</published>
    <updated>2014-11-15T15:52:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="感悟">感悟</h2>
<p>SDN看了也有两个月了吧，刚接触时很兴奋呐，感觉就是一控制器加一交换机呗。<br>弄懂里面的函数结构，接下来搞编程应该就可以了吧~~可是这仅仅是我天真的想<br>法。当别人问我为什么是这样的时候，放到最初那会儿，我会干脆的说：SDN就<br>是这样啊；而现在，我会很小心地分析它的协议流程，害怕漏掉或者说错某个细<br>节。越了解越敬畏，一个概念的产生并且盛行是经过许多学者推敲和认证的，所<br>以无论是做科研还是学术，我们都应有一个严谨的态度。</p>
<h2 id="两主机通信过程">两主机通信过程</h2>
<p>本次实验环境Floodlight+Mininet。我们利用mininet仿真出一个switch下三台hosts：h1,h2,<br>h3,然后h2 ping h3;通过wirshark抓包分析openflow的协议流程。 （在本文我就不分析不同<br>switch下不同host的ping包过程了）默认加载了转发模块。<br>拓扑图如下：<br><img src="/img/topo.png" alt="topo">     </p>
<p>1.最初h2会通过将自己和h3的ip地址同子网掩码与运算得知：自己和h3在同一网段，可直接通信；<br>2.h2对数据包二层封装时，发现自己并不知道h3的mac地址，于是发送ARP广播包；<br>3.switch收到arp广播包后，由于没有流表，于是它向控制器发送packet_in消息：<br>4.控制器收到packet_in后，向switch发送packet_out,并下发流表给switch让它将数据包从除2端口以外的其他所有<br>端口发送；<br>5.h3收到arp数据包后，在数据包里添加上自己的mac地址；<br>6.switch收到h3的arp包，由于没有流表项，于是向控制器发送packet_in消息；<br>7.控制器学习到h3的mac和ip地址，向switch发送packet_out消息并下发h3到h2的流表项；<br>8.h2知道了h3的mac地址，完成icmp包的封装，就向h3发包了；<br>9.由于switch没有h2-&gt;h3的流表项，所以它还是会向控制器发送packet_in；<br>10.控制器发送packet_out给switch并下发h2-&gt;h3的流表；至此h2和h3就能不通过控制器只通过switch直接通信啦！<br>下面是寻址阶段抓包截图：（注：抓取的是通过eth0的包，eth0与控制器通信，所以也就是抓的控制器的包）<br><img src="/img/ping过程.png" alt="ping过程">     </p>
<p>寻址结束后，抓取控制器的包时，没有了h2 ping h3的icmp包,在端口2抓包：<br><img src="/img/s1-eth2.png" alt="端口2">   </p>
<p>在端口3抓包：<br><img src="/img/s1-eth3.png" alt="端口3">   </p>
<h2 id="Openflow与传统路由的比较">Openflow与传统路由的比较</h2>
<p>Openflow与传统路由一样，在源主机不知道目的主机mac地址的情况下，都会进行arp寻址。但不同之处在于，传统路<br>由没有控制器，所有流表在switch里,转发和控制都由switch负责；而Openflow协议里，switch若没有匹配流表（或者<br>没有流表），它会向控制器发送请求，让控制器下发策略。<br><strong>这是我个人的分析，欢迎指正，大家共同学习，若转载请注明出处！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="感悟">感悟</h2>
<p>SDN看了也有两个月了吧，刚接触时很兴奋呐，感觉就是一控制器加一交换机呗。<br>弄懂里面的函数结构，接下来搞编程应该就可以了吧~~可是这仅仅是我天真的想<br>法。当别人问我为什么是这样的时候，放到最初那会儿，我会干脆的说：SDN就]]>
    </summary>
    
      <category term="floodlight" scheme="http://liushy.com/tags/floodlight/"/>
    
      <category term="ping" scheme="http://liushy.com/tags/ping/"/>
    
      <category term="openflow" scheme="http://liushy.com/tags/openflow/"/>
    
      <category term="SDN" scheme="http://liushy.com/categories/SDN/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[openwrt-example]]></title>
    <link href="http://liushy.com/2014/11/14/openwrt-example/"/>
    <id>http://liushy.com/2014/11/14/openwrt-example/</id>
    <published>2014-11-14T15:27:00.000Z</published>
    <updated>2014-11-14T14:29:41.000Z</updated>
    <content type="html"><![CDATA[<p>这里的开发环境是在Ubuntu下，搭建好OpenWrt的交叉编译环境，这里不多说了，网上有很多教程。本次示例选择的OpenWrt版本是trunk版.     </p>
<a id="more"></a>     

<p>接下来是添加模块具体步骤：<br>1.进入trunk的package文件夹，创建模块目录：<br>cd trunk/package<br>mkdir example<br>2.进入example目录，创建Mackefile文件和代码路径：<br>cd example<br>touch Mackefile<br>mkdir src<br>Makefile代码如下：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">include $(TOPDIR)/rules.mk   </div><div class="line">include $(INCLUDE_DIR)/kernel.mk   </div><div class="line"></div><div class="line"><span class="constant">PKG_NAME</span>:=example</div><div class="line"><span class="constant">PKG_RELEASE</span>:=1</div><div class="line"></div><div class="line">include $(INCLUDE_DIR)/package.mk</div><div class="line"></div><div class="line">define KernelPackage/example</div><div class="line">  SUBMENU:=Other modules</div><div class="line">  TITLE:=example driver</div><div class="line">  DEPENDS:=@LINUX_2_6</div><div class="line">  FILES:=$(PKG_BUILD_DIR)/*.$(LINUX_KMOD_SUFFIX)</div><div class="line">  KCONFIG:=</div><div class="line">endef</div><div class="line"></div><div class="line">define KernelPackage/example/description</div><div class="line">  Kernel module to example</div><div class="line">endef</div><div class="line"></div><div class="line"><span class="constant">EXTRA_KCONFIG</span>:= \</div><div class="line">	CONFIG_EXAMPLE=m</div><div class="line"></div><div class="line"><span class="constant">EXTRA_CFLAGS</span>:= \</div><div class="line">	<span class="variable">$(patsubst CONFIG_%, -DCONFIG_%=1, $(patsubst %=m,%,$(filter %=m,$(EXTRA_KCONFIG)</span>))) \</div><div class="line">	<span class="variable">$(patsubst CONFIG_%, -DCONFIG_%=1, $(patsubst %=y,%,$(filter %=y,$(EXTRA_KCONFIG)</span>))) \</div><div class="line"></div><div class="line"><span class="constant">MAKE_OPTS</span>:= \</div><div class="line">	ARCH=<span class="string">"$(LINUX_KARCH)"</span> \</div><div class="line">	CROSS_COMPILE=<span class="string">"$(TARGET_CROSS)"</span> \</div><div class="line">	SUBDIRS=<span class="string">"$(PKG_BUILD_DIR)"</span> \</div><div class="line">	EXTRA_CFLAGS=<span class="string">"$(EXTRA_CFLAGS)"</span> \</div><div class="line">	<span class="variable">$(EXTRA_KCONFIG)</span></div><div class="line"></div><div class="line">define Build/Prepare</div><div class="line">	mkdir -p <span class="variable">$(PKG_BUILD_DIR)</span></div><div class="line">	<span class="variable">$(CP)</span> ./src/* <span class="variable">$(PKG_BUILD_DIR)</span>/</div><div class="line">endef</div><div class="line"></div><div class="line">define Build/Compile</div><div class="line">	<span class="variable">$(MAKE)</span> -C <span class="string">"$(LINUX_DIR)"</span> \</div><div class="line">		<span class="variable">$(MAKE_OPTS)</span> \</div><div class="line">		modules</div><div class="line">endef</div><div class="line"></div><div class="line">$(eval $(call KernelPackage,example))</div></pre></td></tr></table></figure>



<p>3.进入src目录，创建代码路径和相关源文件<br>cd src<br>touch example.c Kconfig Makefile<br>example.c代码：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/init.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/module.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/kernel.h&gt;</span></div><div class="line"><span class="comment">/* hello_init ---- 初始化函数，当模块装载时被调用，如果成功装载返回0 否则返回非0值 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init hello_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">	printk(<span class="string">"I bear a charmed life.\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"><span class="comment">/* hello_exit ---- 退出函数，当模块卸载时被调用 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit hello_exit(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">	printk(<span class="string">"Out, out, brief candle\n"</span>);</div><div class="line">}</div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"liuxie"</span>);</div></pre></td></tr></table></figure>







]]></content>
    <summary type="html">
    <![CDATA[<p>这里的开发环境是在Ubuntu下，搭建好OpenWrt的交叉编译环境，这里不多说了，网上有很多教程。本次示例选择的OpenWrt版本是trunk版.     </p>
]]>
    
    </summary>
    
      <category term="openwrt" scheme="http://liushy.com/tags/openwrt/"/>
    
      <category term="openwrt" scheme="http://liushy.com/categories/openwrt/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://liushy.com/2014/11/14/hello-world/"/>
    <id>http://liushy.com/2014/11/14/hello-world/</id>
    <published>2014-11-14T15:23:15.000Z</published>
    <updated>2014-11-14T08:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>
